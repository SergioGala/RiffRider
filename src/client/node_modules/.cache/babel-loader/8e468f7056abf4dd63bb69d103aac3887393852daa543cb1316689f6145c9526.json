{"ast":null,"code":"const mockApiDelay = 1000;\nconst MAX_REQUESTS_PER_USER = 3;\nconst REQUEST_COOLDOWN = 15 * 60 * 1000; // 15 minutos en milisegundos\n\nlet userRequests = {};\nlet requestQueue = [];\nexport const submitSongRequest = async (request, userId) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (!userRequests[userId]) {\n        userRequests[userId] = [];\n      }\n\n      // Limpiar solicitudes antiguas\n      const now = Date.now();\n      userRequests[userId] = userRequests[userId].filter(req => now - req.timestamp < REQUEST_COOLDOWN);\n      if (userRequests[userId].length >= MAX_REQUESTS_PER_USER) {\n        reject({\n          status: 'error',\n          message: `Has alcanzado el límite de ${MAX_REQUESTS_PER_USER} solicitudes en 15 minutos. Por favor, espera antes de hacer otra solicitud.`\n        });\n      } else if (Math.random() > 0.1) {\n        // 90% de probabilidad de éxito\n        userRequests[userId].push({\n          timestamp: now\n        });\n        const newRequest = {\n          id: Date.now(),\n          ...request,\n          status: 'pending'\n        };\n        requestQueue.push(newRequest);\n        resolve({\n          status: 'success',\n          message: 'Solicitud enviada con éxito'\n        });\n      } else {\n        reject({\n          status: 'error',\n          message: 'Error al enviar la solicitud'\n        });\n      }\n    }, mockApiDelay);\n  });\n};\nexport const getRemainingRequests = userId => {\n  if (!userRequests[userId]) {\n    return MAX_REQUESTS_PER_USER;\n  }\n  const now = Date.now();\n  const activeRequests = userRequests[userId].filter(req => now - req.timestamp < REQUEST_COOLDOWN);\n  return Math.max(0, MAX_REQUESTS_PER_USER - activeRequests.length);\n};\nexport const getRequestQueue = async () => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(requestQueue.filter(req => req.status === 'pending'));\n    }, 500);\n  });\n};\nexport const updateRequestStatus = async (requestId, status) => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      const index = requestQueue.findIndex(req => req.id === requestId);\n      if (index !== -1) {\n        requestQueue[index].status = status;\n        if (status === 'accepted' || status === 'rejected') {\n          requestQueue.splice(index, 1);\n        }\n      }\n      resolve({\n        status: 'success',\n        message: 'Estado de la solicitud actualizado'\n      });\n    }, 500);\n  });\n};","map":{"version":3,"names":["mockApiDelay","MAX_REQUESTS_PER_USER","REQUEST_COOLDOWN","userRequests","requestQueue","submitSongRequest","request","userId","Promise","resolve","reject","setTimeout","now","Date","filter","req","timestamp","length","status","message","Math","random","push","newRequest","id","getRemainingRequests","activeRequests","max","getRequestQueue","updateRequestStatus","requestId","index","findIndex","splice"],"sources":["/workspaces/RiffRider/src/client/src/services/SongRequestService.js"],"sourcesContent":["const mockApiDelay = 1000;\nconst MAX_REQUESTS_PER_USER = 3;\nconst REQUEST_COOLDOWN = 15 * 60 * 1000; // 15 minutos en milisegundos\n\nlet userRequests = {};\nlet requestQueue = [];\n\nexport const submitSongRequest = async (request, userId) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (!userRequests[userId]) {\n        userRequests[userId] = [];\n      }\n\n      // Limpiar solicitudes antiguas\n      const now = Date.now();\n      userRequests[userId] = userRequests[userId].filter(\n        req => now - req.timestamp < REQUEST_COOLDOWN\n      );\n\n      if (userRequests[userId].length >= MAX_REQUESTS_PER_USER) {\n        reject({ \n          status: 'error', \n          message: `Has alcanzado el límite de ${MAX_REQUESTS_PER_USER} solicitudes en 15 minutos. Por favor, espera antes de hacer otra solicitud.` \n        });\n      } else if (Math.random() > 0.1) { // 90% de probabilidad de éxito\n        userRequests[userId].push({ timestamp: now });\n        const newRequest = { id: Date.now(), ...request, status: 'pending' };\n        requestQueue.push(newRequest);\n        resolve({ status: 'success', message: 'Solicitud enviada con éxito' });\n      } else {\n        reject({ status: 'error', message: 'Error al enviar la solicitud' });\n      }\n    }, mockApiDelay);\n  });\n};\n\nexport const getRemainingRequests = (userId) => {\n  if (!userRequests[userId]) {\n    return MAX_REQUESTS_PER_USER;\n  }\n\n  const now = Date.now();\n  const activeRequests = userRequests[userId].filter(\n    req => now - req.timestamp < REQUEST_COOLDOWN\n  );\n\n  return Math.max(0, MAX_REQUESTS_PER_USER - activeRequests.length);\n};\n\nexport const getRequestQueue = async () => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(requestQueue.filter(req => req.status === 'pending'));\n    }, 500);\n  });\n};\n\nexport const updateRequestStatus = async (requestId, status) => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      const index = requestQueue.findIndex(req => req.id === requestId);\n      if (index !== -1) {\n        requestQueue[index].status = status;\n        if (status === 'accepted' || status === 'rejected') {\n          requestQueue.splice(index, 1);\n        }\n      }\n      resolve({ status: 'success', message: 'Estado de la solicitud actualizado' });\n    }, 500);\n  });\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}